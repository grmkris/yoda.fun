# MARKET GENERATION SYSTEM - COMPLETE REFERENCE
# Generated: $(date)

================================================================================
                              HIGH-LEVEL OVERVIEW
================================================================================

## Flow

┌─────────────────────────────────────────────────────────────────┐
│                    TRENDING RESEARCH (3 sources)                │
├─────────────────────────────────────────────────────────────────┤
│  Exa Search          │  xAI xSearch      │  Google Search       │
│  - Sports schedules  │  - Twitter viral  │  - News events       │
│  - Movie releases    │  - Memes          │  - Politics          │
│  - TV premieres      │  - Celebrity      │  - Weather           │
│  - Tech launches     │  - Influencers    │  - Announcements     │
└──────────┬───────────┴────────┬──────────┴──────────┬───────────┘
           │                    │                     │
           └────────────────────┼─────────────────────┘
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    CURATION (Gemini)                            │
│  - Selects TOP 20 topics                                        │
│  - Assigns categories                                           │
│  - Filters for clear YES/NO outcomes                            │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                 DISTRIBUTION GUIDANCE                           │
│  - Checks 24h category distribution                             │
│  - Identifies underrepresented categories                       │
│  - Crypto cap check (max 12/day)                                │
│  - Returns soft guidance: "Prioritize: sports, movies..."      │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              MARKET GENERATION (Grok)                           │
│  - Batch of 8 markets per 30 min                                │
│  - Uses curated topics + distribution guidance                  │
│  - AI picks best topics naturally                               │
│  - Generates title, description, resolution criteria            │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                 IMAGE GENERATION                                │
│  1. AI generates prompt + tags + reuseOk                        │
│  2. If reuseOk → search for matching image by tags              │
│  3. If found → reuse (link market.mediaId)                      │
│  4. If not → generate new via Replicate, save with tags         │
└─────────────────────────────────────────────────────────────────┘


## Key Files

| File                                    | Purpose                              |
|-----------------------------------------|--------------------------------------|
| trending-research.ts                    | 3-source search (Exa, xSearch, Google) |
| distribution.ts                         | Category balancing, crypto cap       |
| prompts.ts                              | AI prompts for generation            |
| service.ts                              | Core generation logic                |
| config.ts                               | Batch size (8), cron (30min)         |
| market-generation.worker.ts             | Worker that runs the pipeline        |
| image-generation.ts                     | AI prompt + tags + reuseOk           |
| image-service.ts                        | Find/create reusable images          |
| market-image.worker.ts                  | Image processing with reuse          |
| media.db.ts                             | Media table with tags[]              |
| market.db.ts                            | Market table with mediaId            |


## Key Changes Made

1. **Soft distribution** - AI gets guidance, not forced categories
2. **Batch generation** - 8 markets/30min instead of 1/6min  
3. **3-source research** - Exa + xSearch + Google in parallel
4. **Image reuse** - Tags for matching, reuseOk flag for AI decision
5. **Schema flip** - market.mediaId instead of media.marketId


## Expected Distribution

| Category     | Target % |
|--------------|----------|
| Sports       | 20%      |
| Movies       | 10%      |
| TV           | 8%       |
| Music        | 8%       |
| Celebrities  | 8%       |
| Gaming       | 8%       |
| Politics     | 8%       |
| Tech         | 8%       |
| Viral        | 7%       |
| Crypto       | 5% (max 12/day) |
| Memes        | 5%       |
| Other        | 3%       |
| Weather      | 2%       |


## Timeframes

| Preset    | Duration      | Probability |
|-----------|---------------|-------------|
| immediate | 1-6 hours     | 33%         |
| short     | 1-3 days      | 33%         |
| medium    | 3-14 days     | 33%         |



================================================================================
FILE: packages/markets/src/generation/trending-research.ts
================================================================================

import type { AiClient } from "@yoda.fun/ai";
import { generateText, Output } from "@yoda.fun/ai";
import type { Logger } from "@yoda.fun/logger";
import { z } from "zod";
import type { CuratedTopic } from "../prompts";

interface TrendingResearchDeps {
  aiClient: AiClient;
  logger: Logger;
}

interface RawTrendingData {
  scheduled: string;
  twitter: string;
  news: string;
}

const CuratedTopicsSchema = z.object({
  topics: z.array(
    z.object({
      topic: z.string(),
      category: z.string(),
      eventDate: z.string().optional(),
      whyGood: z.string(),
    })
  ),
});

export async function researchTrendingTopics(
  deps: TrendingResearchDeps
): Promise<RawTrendingData> {
  const { aiClient, logger } = deps;

  const model = aiClient.getGoogleModel("gemini-2.5-flash");
  const xaiModel = aiClient.getModel({ provider: "xai", modelId: "grok-3-mini" });
  const { googleSearch } = aiClient.getGoogleTools();
  const { xSearch } = aiClient.getXaiTools();

  // Exa: Scheduled events with clear dates
  const exaQueries = [
    "NBA NFL NHL MLB sports games schedule today tomorrow this week",
    "movies releasing this week box office predictions theater",
    "TV show premieres finales streaming Netflix HBO this week",
    "tech product launches announcements Apple Google this week",
  ];

  // xSearch: Twitter/X real-time buzz
  const twitterQueries = [
    "trending viral moments celebrity drama today",
    "memes going viral TikTok challenges internet culture",
    "influencer news milestones subscribers followers",
  ];

  // Google: General news with outcomes
  const googlePrompt = `What are today's top news with clear outcomes?
- Political events, votes, elections
- Court rulings and verdicts
- Weather events and records
- Award ceremonies
List specific events with dates.`;

  logger.info("Starting 3-source trending research");

  const [exaResults, twitterResults, googleResult] = await Promise.all([
    // Exa searches
    Promise.all(
      exaQueries.map((q) =>
        aiClient.searchWithExa(q).then((r) => r.text).catch(() => "")
      )
    ),
    // xSearch (Twitter)
    Promise.all(
      twitterQueries.map((q) =>
        generateText({ model: xaiModel, tools: { xSearch: xSearch({}) }, prompt: q })
          .then((r) => r.text)
          .catch(() => "")
      )
    ),
    // Google search
    generateText({ model, tools: { google_search: googleSearch({}) }, prompt: googlePrompt })
      .then((r) => r.text)
      .catch(() => ""),
  ]);

  logger.info({
    exaCount: exaResults.filter(Boolean).length,
    twitterCount: twitterResults.filter(Boolean).length,
    hasGoogle: !!googleResult,
  }, "Trending research complete");

  return {
    scheduled: exaResults.join("\n\n"),
    twitter: twitterResults.join("\n\n"),
    news: googleResult,
  };
}

export async function curateBestTopics(
  rawData: RawTrendingData,
  deps: TrendingResearchDeps
): Promise<CuratedTopic[]> {
  const { aiClient } = deps;
  const model = aiClient.getGoogleModel("gemini-2.5-flash");

  const prompt = `Select TOP 20 prediction market topics from this data.

## SCHEDULED EVENTS (from Exa - sports, movies, TV, tech)
${rawData.scheduled || "None"}

## TWITTER/X TRENDING (viral, memes, celebrities)
${rawData.twitter || "None"}

## NEWS (politics, weather, announcements)
${rawData.news || "None"}

## CRITERIA
- Clear YES/NO outcome, happening in 24-72h
- Engaging for casual users (not just crypto traders!)
- Diverse mix across categories
- Categories: movies, tv, music, celebrities, gaming, sports, politics, tech, crypto, viral, memes, weather, other

Return JSON: { topics: [{ topic, category, eventDate?, whyGood }] }`;

  const result = await aiClient.generateText({
    model,
    output: Output.object({ schema: CuratedTopicsSchema }),
    prompt,
  });

  return result.output?.topics ?? [];
}

export async function getTrendingTopics(
  deps: TrendingResearchDeps
): Promise<CuratedTopic[]> {
  const rawData = await researchTrendingTopics(deps);
  return curateBestTopics(rawData, deps);
}

================================================================================
FILE: packages/markets/src/generation/distribution.ts
================================================================================

import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { count, gte, sql } from "@yoda.fun/db/drizzle";
import { CATEGORY_DISTRIBUTION, CRYPTO_DAILY_CAP } from "../config";
import { MARKET_CATEGORIES } from "@yoda.fun/shared/market.schema";

export type MarketCategory = (typeof MARKET_CATEGORIES)[number];

export interface CategoryStats {
  category: MarketCategory;
  count: number;
  percentage: number;
  targetPercentage: number;
  deficit: number;
}

export async function getCategoryDistribution(
  db: Database
): Promise<CategoryStats[]> {
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const results = await db
    .select({
      category: DB_SCHEMA.market.category,
      count: count(),
    })
    .from(DB_SCHEMA.market)
    .where(gte(DB_SCHEMA.market.createdAt, oneDayAgo))
    .groupBy(DB_SCHEMA.market.category);

  const countMap = new Map<string, number>();
  for (const row of results) {
    if (row.category) {
      countMap.set(row.category, row.count);
    }
  }

  const total = results.reduce((sum, r) => sum + r.count, 0) || 1;

  return MARKET_CATEGORIES.map((category) => {
    const cnt = countMap.get(category) || 0;
    const pct = cnt / total;
    const target = CATEGORY_DISTRIBUTION[category] ?? 0.03;
    return {
      category,
      count: cnt,
      percentage: pct,
      targetPercentage: target,
      deficit: target - pct,
    };
  });
}

export async function isCryptoAllowed(db: Database): Promise<boolean> {
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const result = await db
    .select({ count: count() })
    .from(DB_SCHEMA.market)
    .where(
      sql`${DB_SCHEMA.market.category} = 'crypto' AND ${DB_SCHEMA.market.createdAt} >= ${oneDayAgo}`
    );

  return (result[0]?.count ?? 0) < CRYPTO_DAILY_CAP;
}

export async function selectNextCategory(db: Database): Promise<MarketCategory> {
  const distribution = await getCategoryDistribution(db);
  const cryptoAllowed = await isCryptoAllowed(db);

  const available = distribution.filter(
    (d) => d.category !== "crypto" || cryptoAllowed
  );

  const withWeights = available.map((d) => ({
    ...d,
    weight: Math.max(0.01, d.deficit + 0.1),
  }));

  const totalWeight = withWeights.reduce((sum, d) => sum + d.weight, 0);
  let random = Math.random() * totalWeight;

  for (const d of withWeights) {
    random -= d.weight;
    if (random <= 0) return d.category;
  }

  return "other";
}

export interface DistributionGuidance {
  deficits: { category: MarketCategory; deficit: number }[];
  atCap: MarketCategory[];
  suggested: string;
}

export async function getDistributionGuidance(
  db: Database
): Promise<DistributionGuidance> {
  const distribution = await getCategoryDistribution(db);
  const cryptoAllowed = await isCryptoAllowed(db);

  const deficits = distribution
    .filter((d) => d.deficit > 0.02)
    .sort((a, b) => b.deficit - a.deficit)
    .slice(0, 5)
    .map((d) => ({ category: d.category, deficit: d.deficit }));

  const atCap: MarketCategory[] = cryptoAllowed ? [] : ["crypto"];

  const prioritize = deficits.map((d) => d.category).join(", ");
  const suggested =
    (prioritize ? `Prioritize: ${prioritize}. ` : "") +
    (atCap.length ? `Avoid: ${atCap.join(", ")} (at daily cap).` : "");

  return { deficits, atCap, suggested };
}

================================================================================
FILE: packages/markets/src/prompts.ts
================================================================================

import type { AIModelConfig } from "@yoda.fun/ai";
import type { TimeframePreset } from "@yoda.fun/shared/market.schema";

const MODELS = {
  XAI_GROK_4_LATEST: {
    provider: "xai",
    modelId: "grok-4-latest",
  } as const satisfies AIModelConfig,

  XAI_GROK_4_1_FAST_REASONING: {
    provider: "xai",
    modelId: "grok-4-1-fast-reasoning",
  } as const satisfies AIModelConfig,

  GOOGLE_GEMINI_2_5_FLASH_THINKING: {
    provider: "google",
    modelId: "gemini-flash-latest",
  } as const satisfies AIModelConfig,
} as const;

export interface CuratedTopic {
  topic: string;
  category: string;
  eventDate?: string;
  whyGood: string;
}

export interface DistributionGuidance {
  deficits: { category: string; deficit: number }[];
  atCap: string[];
  suggested: string;
}

export interface MarketGenerationContext {
  currentDate: string;
  categories?: string[];
  existingMarketTitles?: string[];
  targetCount: number;
  timeframe: TimeframePreset;
  /** Curated trending topics from research phase */
  curatedTopics?: CuratedTopic[];
  /** Soft distribution guidance (categories to prioritize/avoid) */
  distributionGuidance?: DistributionGuidance;
}

export interface MarketResolutionContext {
  marketTitle: string;
  marketDescription: string;
  resolutionCriteria?: string;
  votingEndedAt: string;
}

function getDurationGuidance(timeframe: TimeframePreset): string {
  return {
    immediate: `   IMPORTANT: Generate ONLY short-term markets (1-6 hours)
   { value: 2, unit: "hours" } - for live events happening NOW
   { value: 4, unit: "hours" } - for events happening today
   { value: 6, unit: "hours" } - maximum allowed duration
   DO NOT use days or months - only hours between 1-6`,
    short: `   Focus on near-term markets (1-3 days preferred)
   { value: 12, unit: "hours" } - for events happening today
   { value: 1, unit: "days" } - for tomorrow (preferred)
   { value: 2, unit: "days" } - for day after tomorrow
   { value: 3, unit: "days" } - maximum preferred duration
   Avoid durations longer than 3 days`,
    medium: `   For events with known future dates (3-14 days)
   { value: 5, unit: "days" } - for events this week
   { value: 7, unit: "days" } - for events next week
   { value: 14, unit: "days" } - maximum duration
   Use when event date is known in advance`,
  }[timeframe];
}

export const MARKET_PROMPTS = {
  generation: {
    model: MODELS.XAI_GROK_4_1_FAST_REASONING,
    systemPrompt: (ctx: MarketGenerationContext): string => {
      const sections: string[] = [];

      sections.push(`You are an expert prediction market creator for a Tinder-style betting app called Yoda.fun.
Your job is to generate engaging, binary YES/NO betting markets based on current events and trends.`);

      sections.push(`## CRITICAL RULES
- Markets MUST be binary (YES or NO outcome only)
- Markets MUST have objective, verifiable resolution criteria
- Markets should be engaging and fun for casual users
- NO markets about death, serious illness, or tragedy
- NO markets that could be manipulated by bettors
- Focus on NORMIE topics: sports games, movies, TV, music, celebrities, viral trends
- Crypto markets are RARE (only 5% of all markets) - prefer other categories`);

      sections.push(`## CONTEXT
- Current date: ${ctx.currentDate}
- Generate exactly ${ctx.targetCount} markets`);

      if (ctx.distributionGuidance?.suggested) {
        sections.push(`## DISTRIBUTION GUIDANCE
${ctx.distributionGuidance.suggested}

Rules:
- Pick the BEST topics regardless of category
- Aim for variety - don't generate multiple markets in the same category
${ctx.distributionGuidance.atCap.length ? `- DO NOT generate: ${ctx.distributionGuidance.atCap.join(", ")} (at daily cap)` : ""}
- Favor underrepresented categories when topics are equally good`);
      } else if (ctx.categories?.length) {
        sections.push(`- Focus on categories: ${ctx.categories.join(", ")}`);
      }

      if (ctx.curatedTopics?.length) {
        sections.push(`## TRENDING TOPICS (use these for inspiration)
${ctx.curatedTopics
  .slice(0, 15)
  .map((t) => `- ${t.topic} (${t.category})${t.eventDate ? ` - ${t.eventDate}` : ""}`)
  .join("\n")}`);
      }

      if (ctx.existingMarketTitles?.length) {
        sections.push(`## AVOID DUPLICATES
These markets already exist, do NOT create similar ones:
${ctx.existingMarketTitles
  .slice(0, 20)
  .map((t) => `- ${t}`)
  .join("\n")}`);
      }

      sections.push(`## OUTPUT REQUIREMENTS
For each market provide:
1. title: Short, punchy question (max 100 chars) ending with "?"
2. description: 1-2 sentences explaining the market context
3. category: One of: movies, tv, music, celebrities, gaming, sports, politics, tech, crypto, viral, memes, weather, other
4. resolutionCriteria: Plain English statement describing how the market resolves.
   This is the MOST IMPORTANT field - an AI will read this to determine YES/NO.

   SPORTS - team, opponent, outcome:
   - "Resolves YES if the Lakers win their game against the Celtics"
   - "Resolves YES if LeBron James scores 30+ points tonight"

   MOVIES/TV - box office, ratings, premieres:
   - "Resolves YES if Avatar 3 opens with $200M+ domestic weekend"
   - "Resolves YES if Stranger Things Season 5 gets 100M+ views in first week"

   MUSIC - chart positions, streams, releases:
   - "Resolves YES if Taylor Swift's new album debuts at #1 on Billboard"
   - "Resolves YES if Bad Bunny gets 100M Spotify streams today"

   CELEBRITIES - social media, announcements:
   - "Resolves YES if MrBeast posts a new video today"
   - "Resolves YES if Kylie Jenner hits 500M Instagram followers"

   VIRAL/MEMES - trends, challenges:
   - "Resolves YES if the trending hashtag reaches 1M tweets"

   CRYPTO (use sparingly) - coin, price, source:
   - "Resolves YES if Bitcoin reaches $100,000 on CoinGecko"

5. duration: How long until voting ends
${getDurationGuidance(ctx.timeframe)}
6. betAmount: Suggested bet amount in USD (0.10, 0.25, 0.50, 1.00, or 5.00)`);

      sections.push(`## GOOD EXAMPLES (diverse categories)
- "Will the Lakers win tonight?" [sports]
  → resolutionCriteria: "Resolves YES if the Los Angeles Lakers win their scheduled NBA game"
  → duration: { value: 3, unit: "hours" }

- "Will Wicked hit $500M box office?" [movies]
  → resolutionCriteria: "Resolves YES if Wicked reaches $500M worldwide box office per Box Office Mojo"
  → duration: { value: 7, unit: "days" }

- "Will MrBeast hit 350M subscribers?" [celebrities]
  → resolutionCriteria: "Resolves YES if MrBeast YouTube channel reaches 350M subscribers"
  → duration: { value: 14, unit: "days" }

- "Will Taylor Swift top Spotify Global today?" [music]
  → resolutionCriteria: "Resolves YES if Taylor Swift is the #1 most streamed artist on Spotify Global today"
  → duration: { value: 12, unit: "hours" }

- "Will the Chiefs beat the Bills?" [sports]
  → resolutionCriteria: "Resolves YES if the Kansas City Chiefs defeat the Buffalo Bills in their NFL game"
  → duration: { value: 4, unit: "hours" }

- "Will it snow in NYC tomorrow?" [weather]
  → resolutionCriteria: "Resolves YES if measurable snowfall is recorded in Central Park tomorrow"
  → duration: { value: 1, unit: "days" }

## BAD EXAMPLES (avoid these patterns)
- "Will the economy improve?" (subjective, unverifiable)
- "Will X be the best movie of the year?" (opinion-based)
- "Will someone famous die?" (morbid, inappropriate)
- "Will Dogecoin pump 20%?" (percentage-based - use absolute price like "hit $0.50" instead)
- Another crypto price prediction (too many already!)`);

      return sections.join("\n\n");
    },
  },

  resolution: {
    model: MODELS.XAI_GROK_4_1_FAST_REASONING,
    systemPrompt: (ctx: MarketResolutionContext): string => {
      const sections: string[] = [];

      sections.push(`You are a neutral market resolution judge for Yoda.fun prediction markets.
Your job is to determine whether a market resolved YES, NO, or INVALID based on facts.`);

      sections.push(`## MARKET TO RESOLVE
Title: ${ctx.marketTitle}
Description: ${ctx.marketDescription}
${ctx.resolutionCriteria ? `Resolution Criteria: ${ctx.resolutionCriteria}` : ""}
Voting Ended: ${ctx.votingEndedAt}`);

      sections.push(`## RESOLUTION RULES
1. Search for reliable sources to verify the outcome
2. Only resolve YES or NO if you have HIGH confidence (>85%)
3. Resolve as INVALID if:
   - The event hasn't happened yet
   - Information is contradictory or unclear
   - The market question was ambiguous
   - External factors made fair resolution impossible
4. Provide 1-3 source URLs that support your decision
5. Include a confidence score (0-100)`);

      sections.push(`## OUTPUT FORMAT
Provide:
- result: "YES", "NO", or "INVALID"
- confidence: 0-100 (your confidence in the resolution)
- reasoning: Brief explanation of your decision
- sources: Array of {url, snippet} with evidence`);

      return sections.join("\n\n");
    },
  },
} as const;

================================================================================
FILE: packages/markets/src/generation/service.ts
================================================================================

import { type AiClient, Output } from "@yoda.fun/ai";
import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { desc } from "@yoda.fun/db/drizzle";
import type { SelectMarket } from "@yoda.fun/db/schema";
import type { Logger } from "@yoda.fun/logger";
import type { CuratedTopic, DistributionGuidance } from "../prompts";
import { MARKET_PROMPTS } from "../prompts";
import {
  type GeneratedMarket,
  GeneratedMarketsResponseSchema,
  type GenerateMarketsInput,
  type GenerateMarketsResult,
} from "@yoda.fun/shared/market.schema";
import { type PreparedMarket, prepareMarket } from "./preparer";

/** Extended input with trending topics and distribution guidance */
export interface GenerateMarketsInputWithTrending extends GenerateMarketsInput {
  curatedTopics?: CuratedTopic[];
  distributionGuidance?: DistributionGuidance;
}

interface MarketGenerationServiceDeps {
  db: Database;
  logger: Logger;
  aiClient: AiClient;
}

const MAX_RETRIES = 3;

function buildPrompt(count: number, attempt: number, lastError?: string) {
  if (attempt === 0) {
    return `Generate ${count} unique betting markets based on current events and trends. Focus on engaging, fun topics that will attract bettors.`;
  }
  return `Generate ${count} unique betting markets. Previous attempt failed: ${lastError}. Please try again with valid data.`;
}

export function createMarketGenerationService(
  deps: MarketGenerationServiceDeps
) {
  const { db, logger, aiClient } = deps;

  async function fetchExistingTitles(): Promise<string[]> {
    const existingMarkets = await db
      .select({ title: DB_SCHEMA.market.title })
      .from(DB_SCHEMA.market)
      .orderBy(desc(DB_SCHEMA.market.createdAt))
      .limit(50);
    return existingMarkets.map((m) => m.title);
  }

  function insertToDatabase(
    markets: PreparedMarket[]
  ): Promise<SelectMarket[]> {
    return db.insert(DB_SCHEMA.market).values(markets).returning();
  }

  async function attemptGeneration(
    input: GenerateMarketsInput,
    systemPrompt: string,
    attempt: number,
    lastError?: string
  ): Promise<GenerateMarketsResult> {
    const startTime = Date.now();
    const config = MARKET_PROMPTS.generation;
    const model = aiClient.getModel(config.model);
    const prompt = buildPrompt(input.count, attempt, lastError);

    const response = await aiClient.generateText({
      model,
      output: Output.object({ schema: GeneratedMarketsResponseSchema }),
      system: systemPrompt,
      prompt,
    });

    const durationMs = Date.now() - startTime;

    logger.info(
      {
        marketsGenerated: response.output.markets.length,
        durationMs,
        tokensUsed: response.usage?.totalTokens ?? 0,
      },
      "Market generation complete"
    );

    return {
      markets: response.output.markets,
      modelVersion: config.model.modelId,
      tokensUsed: response.usage?.totalTokens ?? 0,
      durationMs,
    };
  }

  const generateMarkets = async (
    input: GenerateMarketsInputWithTrending
  ): Promise<GenerateMarketsResult> => {
    const config = MARKET_PROMPTS.generation;

    logger.info(
      {
        count: input.count,
        categories: input.categories,
        hasDistributionGuidance: !!input.distributionGuidance,
        hasCuratedTopics: !!input.curatedTopics?.length,
      },
      "Generating markets with AI"
    );

    const existingTitles = await fetchExistingTitles();
    const currentDate = new Date().toISOString().split("T")[0] ?? "";
    const systemPrompt = config.systemPrompt({
      currentDate,
      categories: input.categories,
      existingMarketTitles: existingTitles,
      targetCount: input.count,
      timeframe: input.timeframe,
      curatedTopics: input.curatedTopics,
      distributionGuidance: input.distributionGuidance,
    });

    let lastError: string | undefined;

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        return await attemptGeneration(input, systemPrompt, attempt, lastError);
      } catch (error) {
        lastError = error instanceof Error ? error.message : String(error);
        logger.warn(
          { attempt: attempt + 1, maxRetries: MAX_RETRIES },
          "Generation failed, retrying"
        );

        if (attempt === MAX_RETRIES - 1) {
          logger.error(
            { error: lastError },
            "Generation failed after all retries"
          );
          throw error;
        }
      }
    }

    throw new Error("Generation failed after all retries");
  };

  const insertMarkets = (
    markets: GeneratedMarket[]
  ): Promise<SelectMarket[]> => {
    const prepared = markets.map((m) => prepareMarket(m, null));
    return insertToDatabase(prepared);
  };

  return {
    async generateAndInsertMarkets(
      input: GenerateMarketsInputWithTrending
    ): Promise<{
      generated: GenerateMarketsResult;
      inserted: SelectMarket[];
    }> {
      const generated = await generateMarkets(input);
      const inserted = await insertMarkets(generated.markets);

      logger.info(
        {
          requested: input.count,
          generated: generated.markets.length,
          inserted: inserted.length,
        },
        "Market generation complete"
      );

      return { generated, inserted };
    },
  };
}

export type MarketGenerationService = ReturnType<
  typeof createMarketGenerationService
>;

================================================================================
FILE: packages/markets/src/config.ts
================================================================================

export const MARKET_GENERATION = {
  BATCH_SIZE: 8,
  CRON: "*/30 * * * *",
} as const;

export const CATEGORY_DISTRIBUTION = {
  movies: 0.1,
  tv: 0.08,
  music: 0.08,
  celebrities: 0.08,
  gaming: 0.08,
  sports: 0.2,
  politics: 0.08,
  tech: 0.08,
  crypto: 0.05,
  viral: 0.07,
  memes: 0.05,
  weather: 0.02,
  other: 0.03,
} as const;

export const CRYPTO_DAILY_CAP = 12;
export const TRENDING_CACHE_TTL = 1800;

================================================================================
FILE: apps/server/src/workers/market-generation.worker.ts
================================================================================

import type { AiClient } from "@yoda.fun/ai";
import type { Database } from "@yoda.fun/db";
import type { Logger } from "@yoda.fun/logger";
import {
  createMarketGenerationService,
  getDistributionGuidance,
  getTrendingTopics,
} from "@yoda.fun/markets/generation";
import type { QueueClient } from "@yoda.fun/queue";

export interface MarketGenerationWorkerConfig {
  queue: QueueClient;
  db: Database;
  logger: Logger;
  aiClient: AiClient;
}

const getTimeframe = () => {
  const random = Math.random();
  if (random < 0.33) {
    return "immediate";
  }
  if (random < 0.66) {
    return "short";
  }
  return "medium";
};

/**
 * Create and start the market generation worker
 * Processes scheduled and manual market generation jobs
 */
export function createMarketGenerationWorker(
  config: MarketGenerationWorkerConfig
): {
  close: () => Promise<void>;
} {
  const { queue, db, logger, aiClient } = config;

  const marketGenerationService = createMarketGenerationService({
    db,
    logger,
    aiClient,
  });

  logger.info({ msg: "Starting market generation worker" });

  // Cache trending topics (refresh every 30 min)
  let cachedTrendingTopics: Awaited<ReturnType<typeof getTrendingTopics>> = [];
  let lastTrendingFetch = 0;
  const TRENDING_CACHE_TTL = 30 * 60 * 1000; // 30 minutes

  const worker = queue.createWorker<"generate-market">(
    "generate-market",
    async (job) => {
      const { count, categories, trigger } = job;

      logger.info(
        { count, categories, trigger },
        "Processing market generation job"
      );

      // For scheduled jobs, use soft distribution guidance
      let distributionGuidance = undefined;
      if (trigger === "scheduled") {
        distributionGuidance = await getDistributionGuidance(db);
        logger.info(
          { suggested: distributionGuidance.suggested },
          "Using distribution guidance"
        );
      }

      // Fetch trending topics (with caching)
      const now = Date.now();
      if (now - lastTrendingFetch > TRENDING_CACHE_TTL) {
        try {
          logger.info("Refreshing trending topics cache");
          cachedTrendingTopics = await getTrendingTopics({ aiClient, logger });
          lastTrendingFetch = now;
          logger.info(
            { topicCount: cachedTrendingTopics.length },
            "Trending topics refreshed"
          );
        } catch (error) {
          logger.warn({ error }, "Failed to fetch trending topics, using cache");
        }
      }

      // Generate and insert markets
      const { generated, inserted } =
        await marketGenerationService.generateAndInsertMarkets({
          count,
          categories,
          timeframe: getTimeframe(),
          curatedTopics: cachedTrendingTopics,
          distributionGuidance,
        });

      // Schedule resolution and image jobs for each new market
      for (const market of inserted) {
        // Queue image generation
        await queue.addJob("generate-market-image", {
          marketId: market.id,
          title: market.title,
          description: market.description ?? "",
          category: market.category ?? "other",
        });

        // Schedule resolution
        const delayMs =
          new Date(market.resolutionDeadline).getTime() - Date.now();

        if (delayMs > 0) {
          await queue.addJob(
            "resolve-market",
            { marketId: market.id },
            { delay: delayMs }
          );

          logger.info(
            {
              marketId: market.id,
              resolutionDeadline: market.resolutionDeadline,
              delayMs,
            },
            "Scheduled resolution job"
          );
        }
      }

      logger.info(
        {
          requested: count,
          generated: generated.markets.length,
          inserted: inserted.length,
          trigger,
        },
        "Market generation job completed"
      );

      return { success: true, marketsCreated: inserted.length };
    },
    {
      onFailed: (job, error) => {
        logger.error({
          msg: "Market generation failed after all retries",
          count: job.count,
          categories: job.categories,
          trigger: job.trigger,
          error: error.message,
        });
        return Promise.resolve();
      },
    }
  );

  return { close: () => worker.close() };
}

================================================================================
FILE: packages/ai/src/image-generation.ts
================================================================================

import Replicate from "replicate";
import { z } from "zod";
import type { AiClient } from "./client";
import { Output } from "./ai-config";

export interface MarketImageContext {
  title: string;
  category: string;
  description: string;
}

export interface ImageGenerationConfig {
  replicateApiKey: string;
}

export interface ImagePromptResult {
  prompt: string;
  tags: string[];
  reuseOk: boolean;
}

const ImagePromptResponseSchema = z.object({
  prompt: z.string(),
  tags: z.array(z.string()),
  reuseOk: z.boolean(),
});

export async function generateImagePromptWithTags(
  market: MarketImageContext,
  aiClient: AiClient
): Promise<ImagePromptResult> {
  const categoryStyles: Record<string, string> = {
    movies: "cinematic, movie poster aesthetic, dramatic lighting",
    tv: "streaming platform vibes, screen glow aesthetic",
    music: "concert stage, vinyl records, vibrant stage lighting",
    celebrities: "glamorous, red carpet, spotlight, magazine cover",
    gaming: "esports arena, neon RGB lighting, gaming setup",
    sports: "dynamic action shot, stadium atmosphere, athletic",
    politics: "professional setting, flags, podiums",
    tech: "futuristic, sleek devices, digital aesthetic",
    crypto: "blockchain visualization, digital coins, cyber aesthetic",
    viral: "trending hashtag, social media icons, phone screen",
    memes: "internet culture, viral aesthetic, bold colors",
    weather: "dramatic sky, weather elements, meteorological",
    other: "modern, clean, professional",
  };

  const style = categoryStyles[market.category] || categoryStyles.other;
  const model = aiClient.getModel({ provider: "google", modelId: "gemini-2.0-flash" });

  const result = await aiClient.generateText({
    model,
    output: Output.object({ schema: ImagePromptResponseSchema }),
    prompt: `Generate an image prompt, reusable tags, and reuse decision for this prediction market:

Title: "${market.title}"
Description: ${market.description}
Category: ${market.category}
Style hints: ${style}

PROMPT: Create a detailed image generation prompt (50-100 words) for a betting card. Include:
- Visual style matching the category
- No text/watermarks
- 2:3 aspect ratio feel
- Eye-catching, professional quality

TAGS: Extract 2-5 reusable tags for image matching:
- Primary entity (team name, person name, coin symbol, etc.)
- Category-level tag if relevant
- Only include entities that would match similar future markets

REUSE_OK: Should we reuse an existing image if tags match?
- true: Generic/recurring topic (regular game, price prediction, ongoing series)
- false: Unique/novel event that deserves a fresh image (record-breaking, historic, first-time, specific moment)

Examples:
- "Will Lakers beat Celtics?" → tags: ["lakers", "nba"], reuseOk: true (regular game)
- "Lakers break 20-game win streak?" → tags: ["lakers", "nba"], reuseOk: false (historic moment)
- "Will Bitcoin hit $100k?" → tags: ["bitcoin", "crypto"], reuseOk: true (price milestone)
- "Bitcoin ETF approved for first time?" → tags: ["bitcoin", "crypto"], reuseOk: false (novel event)`,
  });

  return result.output;
}

function buildImagePrompt(market: MarketImageContext): string {
  const categoryStyles: Record<string, string> = {
    // Entertainment subcategories
    movies:
      "cinematic scene, movie poster aesthetic, dramatic lighting, film reel elements",
    tv: "living room screen glow, streaming platform vibes, binge-worthy aesthetic",
    music:
      "concert stage, vinyl records, musical notes, vibrant stage lighting",
    celebrities:
      "glamorous, red carpet, paparazzi flash, spotlight, magazine cover feel",
    gaming:
      "esports arena, gaming setup, neon RGB lighting, controller and screen",
    // Core categories
    sports: "dynamic action shot, stadium atmosphere, vibrant colors, athletic",
    politics: "professional setting, flags, podiums, dramatic lighting",
    tech: "futuristic, sleek devices, neon accents, digital aesthetic",
    crypto:
      "blockchain visualization, digital coins, cyber aesthetic, gold and blue",
    // Social/Viral
    viral:
      "trending hashtag, social media icons, phone screen, notification aesthetic",
    memes: "internet culture, viral aesthetic, bold colors, humorous tone",
    // Misc
    weather:
      "dramatic sky, weather elements, meteorological, clouds and sun or storms",
    other: "modern, clean, professional, engaging",
  };

  const style = categoryStyles[market.category] || categoryStyles.other;

  return `Create a visually striking, eye-catching image for a prediction market betting card.

Topic: "${market.title}"
Context: ${market.description}

Style requirements:
- ${style}
- Suitable for a mobile card UI (2:3 aspect ratio feel)
- No text overlays or watermarks
- High contrast, attention-grabbing
- Professional quality, suitable for a betting app`;
}

export async function generateMarketImageBuffer(
  market: MarketImageContext,
  config: ImageGenerationConfig
): Promise<Buffer | null> {
  const replicate = new Replicate({
    auth: config.replicateApiKey,
  });
  const prompt = buildImagePrompt(market);

  const output = (await replicate.run("google/nano-banana", {
    input: {
      prompt,
      aspect_ratio: "2:3",
      output_format: "png",
    },
  })) as { url: () => Promise<string>; blob: () => Promise<Blob> };

  const imageBuffer = await output.blob();
  return Buffer.from(await imageBuffer.arrayBuffer());
}

export async function generateMarketImageUrl(
  market: MarketImageContext,
  config: ImageGenerationConfig
): Promise<string | null> {
  const replicate = new Replicate({
    auth: config.replicateApiKey,
  });
  const prompt = buildImagePrompt(market);

  const output = (await replicate.run("google/nano-banana", {
    input: {
      prompt,
      aspect_ratio: "2:3",
      output_format: "png",
    },
  })) as { url: () => Promise<string>; blob: () => Promise<Blob> };

  return output.url();
}

export async function fetchImageBuffer(url: string): Promise<Buffer> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.status}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer);
}

================================================================================
FILE: packages/markets/src/generation/image-service.ts
================================================================================

import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { and, desc, eq, sql } from "@yoda.fun/db/drizzle";
import type { MediaId } from "@yoda.fun/shared/typeid";

export interface ImageServiceDeps {
  db: Database;
}

export function createImageService(deps: ImageServiceDeps) {
  const { db } = deps;

  async function findReusableImage(tags: string[]): Promise<MediaId | null> {
    if (!tags.length) return null;

    const match = await db.query.media.findFirst({
      where: and(
        eq(DB_SCHEMA.media.type, "market_image"),
        eq(DB_SCHEMA.media.status, "processed"),
        sql`${DB_SCHEMA.media.tags} && ${tags}`,
      ),
      orderBy: desc(DB_SCHEMA.media.createdAt),
    });

    return (match?.id as MediaId) ?? null;
  }

  async function createImageMedia(
    imageUrl: string,
    tags: string[],
    prompt: string
  ): Promise<MediaId> {
    const [inserted] = await db
      .insert(DB_SCHEMA.media)
      .values({
        type: "market_image",
        source: "replicate",
        status: "processed",
        sourceUrl: imageUrl,
        tags,
        metadata: { prompt },
      })
      .returning();

    if (!inserted) {
      throw new Error("Failed to insert media record");
    }

    return inserted.id as MediaId;
  }

  async function linkMediaToMarket(
    marketId: string,
    mediaId: MediaId
  ): Promise<void> {
    await db
      .update(DB_SCHEMA.market)
      .set({ mediaId })
      .where(eq(DB_SCHEMA.market.id, marketId));
  }

  return {
    findReusableImage,
    createImageMedia,
    linkMediaToMarket,
  };
}

export type ImageService = ReturnType<typeof createImageService>;

================================================================================
FILE: apps/server/src/workers/market-image.worker.ts
================================================================================

import type { AiClient } from "@yoda.fun/ai";
import {
  fetchImageBuffer,
  generateImagePromptWithTags,
  generateMarketImageUrl,
} from "@yoda.fun/ai/image-generation";
import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { eq } from "@yoda.fun/db/drizzle";
import type { Logger } from "@yoda.fun/logger";
import { createImageService } from "@yoda.fun/markets/generation";
import { processMarketImage } from "@yoda.fun/markets/image-processing";
import type { QueueClient } from "@yoda.fun/queue";
import type { StorageClient } from "@yoda.fun/storage";

export interface MarketImageWorkerConfig {
  queue: QueueClient;
  db: Database;
  logger: Logger;
  storage: StorageClient;
  aiClient: AiClient;
  replicateApiKey: string;
}

export function createMarketImageWorker(config: MarketImageWorkerConfig): {
  close: () => Promise<void>;
} {
  const { queue, db, logger, storage, aiClient, replicateApiKey } = config;

  logger.info({ msg: "Starting market image worker" });

  const imageService = createImageService({ db });

  const worker = queue.createWorker<"generate-market-image">(
    "generate-market-image",
    async (job) => {
      const { marketId, title, description, category } = job;

      logger.info({ marketId, title }, "Processing market image");

      // Check if market already has an image
      const [market] = await db
        .select({ mediaId: DB_SCHEMA.market.mediaId, imageUrl: DB_SCHEMA.market.imageUrl })
        .from(DB_SCHEMA.market)
        .where(eq(DB_SCHEMA.market.id, marketId))
        .limit(1);

      if (market?.imageUrl) {
        logger.info({ marketId }, "Market already has image, skipping");
        return { success: true, marketId, imageUrl: market.imageUrl };
      }

      // Generate prompt, tags, and reuse decision via AI
      const { prompt, tags, reuseOk } = await generateImagePromptWithTags(
        { title, description, category },
        aiClient
      );

      logger.info({ marketId, tags, reuseOk }, "Generated image prompt and tags");

      // Try to find reusable image if AI says it's ok to reuse
      let mediaId = reuseOk ? await imageService.findReusableImage(tags) : null;
      let reused = false;

      if (mediaId) {
        logger.info({ marketId, mediaId, tags }, "Reusing existing image");
        reused = true;
      } else {
        // Generate new image
        logger.info({ marketId }, "Generating new image via Replicate");

        const sourceUrl = await generateMarketImageUrl(
          { title, description, category },
          { replicateApiKey }
        );

        if (!sourceUrl) {
          logger.warn({ marketId }, "Image generation returned null");
          return { success: false, marketId };
        }

        // Fetch and process the image
        const imageBuffer = await fetchImageBuffer(sourceUrl);
        const { imageUrl: finalKey, thumbnailUrl: thumbnailKey } =
          await processMarketImage(imageBuffer, { storage });

        // Create media record with tags for future reuse
        mediaId = await imageService.createImageMedia(finalKey, tags, prompt);

        // Update media with processed keys
        await db
          .update(DB_SCHEMA.media)
          .set({ finalKey, thumbnailKey, status: "processed" })
          .where(eq(DB_SCHEMA.media.id, mediaId));

        logger.info({ marketId, mediaId, tags }, "Created new reusable image");
      }

      // Get the media record to get URLs
      const [media] = await db
        .select()
        .from(DB_SCHEMA.media)
        .where(eq(DB_SCHEMA.media.id, mediaId))
        .limit(1);

      // Update market with media reference and URLs
      await db
        .update(DB_SCHEMA.market)
        .set({
          mediaId,
          imageUrl: media?.finalKey ?? media?.sourceUrl,
          thumbnailUrl: media?.thumbnailKey,
          status: "LIVE",
        })
        .where(eq(DB_SCHEMA.market.id, marketId));

      logger.info(
        { marketId, mediaId, reused, tags },
        "Market image processed successfully"
      );

      return {
        success: true,
        marketId,
        mediaId,
        reused,
        imageUrl: media?.finalKey,
        thumbnailUrl: media?.thumbnailKey,
      };
    },
    {
      onFailed: (job, error) => {
        logger.error({
          msg: "Image generation failed after all retries",
          marketId: job.marketId,
          error: error.message,
        });
        return Promise.resolve();
      },
    }
  );

  return { close: () => worker.close() };
}

================================================================================
FILE: packages/db/src/schema/media/media.db.ts
================================================================================

import {
  type MediaId,
  typeIdGenerator,
  type UserId,
} from "@yoda.fun/shared/typeid";
import {
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
} from "drizzle-orm/pg-core";
import { baseEntityFields, typeId } from "../../utils/db-utils";
import { user } from "../auth/auth.db";

export const mediaTypeEnum = pgEnum("media_type", [
  "market_image",
  "market_thumbnail",
  "user_avatar",
]);

export const mediaSourceEnum = pgEnum("media_source", [
  "replicate",
  "upload",
  "external",
]);

export const mediaStatusEnum = pgEnum("media_status", [
  "pending",
  "source_ready",
  "processed",
  "failed",
]);

export interface MediaMetadata {
  prompt?: string;
  model?: string;
  replicatePredictionId?: string;
  aspectRatio?: string;
  originalFilename?: string;
  mimeType?: string;
  fileSize?: number;
  width?: number;
  height?: number;
}

export const media = pgTable(
  "media",
  {
    id: typeId("media", "id")
      .primaryKey()
      .$defaultFn(() => typeIdGenerator("media"))
      .$type<MediaId>(),

    type: mediaTypeEnum("type").notNull(),
    source: mediaSourceEnum("source").notNull(),
    status: mediaStatusEnum("status").notNull().default("pending"),

    sourceUrl: text("source_url"),
    finalKey: text("final_key"),
    thumbnailKey: text("thumbnail_key"),
    metadata: jsonb("metadata").$type<MediaMetadata>(),
    errorMessage: text("error_message"),
    retryCount: integer("retry_count").notNull().default(0),

    tags: text("tags").array(),
    userId: typeId("user", "user_id")
      .references(() => user.id, { onDelete: "cascade" })
      .$type<UserId>(),

    ...baseEntityFields,
  },
  (table) => [
    index("idx_media_user").on(table.userId),
    index("idx_media_status").on(table.status),
    index("idx_media_type_status").on(table.type, table.status),
    index("idx_media_tags").using("gin", table.tags),
  ]
);

================================================================================
FILE: packages/db/src/schema/market/market.db.ts
================================================================================

import type { ResolutionStrategy } from "@yoda.fun/shared/resolution-types";
import {
  type BetId,
  type MarketId,
  type MediaId,
  type SettlementBatchId,
  typeIdGenerator,
  type UserBalanceId,
  type UserId,
} from "@yoda.fun/shared/typeid";
import {
  integer,
  jsonb,
  numeric,
  pgEnum,
  pgTable,
  text,
  unique,
} from "drizzle-orm/pg-core";
import {
  baseEntityFields,
  createTimestampField,
  typeId,
} from "../../utils/db-utils";
import { user } from "../auth/auth.db";

// Enums
export const marketStatusEnum = pgEnum("market_status", [
  "PROCESSING",
  "LIVE",
  "VOTING_ENDED",
  "SETTLED",
  "CANCELLED",
]);

export const marketResultEnum = pgEnum("market_result", [
  "YES",
  "NO",
  "INVALID",
]);

export const betVoteEnum = pgEnum("bet_vote", ["YES", "NO"]);

export const betStatusEnum = pgEnum("bet_status", [
  "ACTIVE",
  "WON",
  "LOST",
  "REFUNDED",
]);

export const settlementStatusEnum = pgEnum("settlement_status", [
  "PENDING",
  "SETTLED",
  "FAILED",
]);

export const resolutionTypeEnum = pgEnum("resolution_type", [
  "PRICE",
  "SPORTS",
  "WEB_SEARCH",
]);

// Tables
export const market = pgTable("market", {
  id: typeId("market", "id")
    .primaryKey()
    .$defaultFn(() => typeIdGenerator("market"))
    .$type<MarketId>(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  imageUrl: text("image_url"),
  thumbnailUrl: text("thumbnail_url"),
  mediaId: typeId("media", "media_id").$type<MediaId>(),
  category: text("category"),
  tags: text("tags").array(),
  status: marketStatusEnum("status").notNull().default("PROCESSING"),
  votingEndsAt: createTimestampField("voting_ends_at").notNull(),
  resolutionDeadline: createTimestampField("resolution_deadline").notNull(),
  betAmount: numeric("bet_amount", { precision: 10, scale: 2 })
    .notNull()
    .default("0.10"),
  totalYesVotes: integer("total_yes_votes").notNull().default(0),
  totalNoVotes: integer("total_no_votes").notNull().default(0),
  totalPool: numeric("total_pool", { precision: 12, scale: 2 })
    .notNull()
    .default("0.00"),
  result: marketResultEnum("result"),
  createdById: typeId("user", "created_by_id")
    .references(() => user.id, { onDelete: "set null" })
    .$type<UserId>(),
  resolvedAt: createTimestampField("resolved_at"),
  resolutionCriteria: text("resolution_criteria"),
  resolutionType: resolutionTypeEnum("resolution_type"),
  resolutionStrategy: jsonb("resolution_strategy").$type<ResolutionStrategy>(),
  resolutionSources:
    jsonb("resolution_sources").$type<
      Array<{ url: string; snippet: string }>
    >(),
  resolutionConfidence: integer("resolution_confidence"),
  ...baseEntityFields,
});

export const bet = pgTable(
  "bet",
  {
    id: typeId("bet", "id")
      .primaryKey()
      .$defaultFn(() => typeIdGenerator("bet"))
      .$type<BetId>(),
    userId: typeId("user", "user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" })
      .$type<UserId>(),
    marketId: typeId("market", "market_id")
      .notNull()
      .references(() => market.id, { onDelete: "cascade" })
      .$type<MarketId>(),
    vote: betVoteEnum("vote").notNull(),
    amount: numeric("amount", { precision: 10, scale: 2 }).notNull(),
    status: betStatusEnum("status").notNull().default("ACTIVE"),
    payout: numeric("payout", { precision: 10, scale: 2 }),
    // Settlement tracking
    settlementStatus: settlementStatusEnum("settlement_status")
      .notNull()
      .default("PENDING"),
    settledAt: createTimestampField("settled_at"),
    settlementTxHash: text("settlement_tx_hash"),
    settlementBatchId: typeId(
      "settlementBatch",
      "settlement_batch_id"
    ).$type<SettlementBatchId>(),
    ...baseEntityFields,
  },
  (table) => [
    // Each user can only bet once per market
    unique("unique_user_market_bet").on(table.userId, table.marketId),
  ]
);

export const userBalance = pgTable("user_balance", {
  id: typeId("userBalance", "id")
    .primaryKey()
    .$defaultFn(() => typeIdGenerator("userBalance"))
    .$type<UserBalanceId>(),
  userId: typeId("user", "user_id")
    .notNull()
    .unique()
    .references(() => user.id, { onDelete: "cascade" })
    .$type<UserId>(),
  availableBalance: numeric("available_balance", { precision: 12, scale: 2 })
    .notNull()
    .default("0.00"),
  pendingBalance: numeric("pending_balance", { precision: 12, scale: 2 })
    .notNull()
    .default("0.00"),
  totalDeposited: numeric("total_deposited", { precision: 12, scale: 2 })
    .notNull()
    .default("0.00"),
  totalWithdrawn: numeric("total_withdrawn", { precision: 12, scale: 2 })
    .notNull()
    .default("0.00"),
  ...baseEntityFields,
});
