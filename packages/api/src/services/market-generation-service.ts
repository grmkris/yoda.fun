import type { AiClient } from "@yoda.fun/ai";
import { FEATURES } from "@yoda.fun/ai/ai-config";
import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { desc } from "@yoda.fun/db/drizzle";
import type { Logger } from "@yoda.fun/logger";
import {
  type GeneratedMarket,
  GeneratedMarketsResponseSchema,
  type GenerateMarketsInput,
  type GenerateMarketsResult,
} from "./market-generation-schemas";

interface MarketGenerationServiceDeps {
  db: Database;
  logger: Logger;
  aiClient: AiClient;
}

const MS_PER_DAY = 24 * 60 * 60 * 1000;
const RESOLUTION_BUFFER_HOURS = 6;

export function createMarketGenerationService({
  deps,
}: {
  deps: MarketGenerationServiceDeps;
}) {
  const { db, logger, aiClient } = deps;

  return {
    /**
     * Generate new markets using AI
     * Returns validated market data ready for DB insertion
     */
    async generateMarkets(
      input: GenerateMarketsInput
    ): Promise<GenerateMarketsResult> {
      const startTime = Date.now();
      const config = FEATURES.marketGeneration;

      logger.info(
        { count: input.count, categories: input.categories },
        "Generating markets with AI"
      );

      // Get existing market titles to avoid duplicates
      const existingMarkets = await db
        .select({ title: DB_SCHEMA.market.title })
        .from(DB_SCHEMA.market)
        .orderBy(desc(DB_SCHEMA.market.createdAt))
        .limit(50);

      const existingTitles = existingMarkets.map((m) => m.title);

      // Build prompt context
      const promptContext = {
        currentDate: new Date().toISOString().split("T")[0] ?? "",
        categories: input.categories,
        existingMarketTitles: existingTitles,
        targetCount: input.count,
      };

      const systemPrompt = config.systemPrompt(promptContext);
      const model = aiClient.getModel(config.model);

      const response = await aiClient.generateObject({
        model,
        schema: GeneratedMarketsResponseSchema,
        system: systemPrompt,
        prompt: `Generate ${input.count} unique betting markets based on current events and trends. Focus on engaging, fun topics that will attract bettors.`,
      });

      const durationMs = Date.now() - startTime;

      logger.info(
        {
          marketsGenerated: response.object.markets.length,
          durationMs,
          tokensUsed: response.usage?.totalTokens,
        },
        "Markets generated successfully"
      );

      return {
        markets: response.object.markets,
        modelVersion: config.model.modelId,
        tokensUsed: response.usage?.totalTokens,
        durationMs,
      };
    },

    /**
     * Insert generated markets into the database
     * Also schedules resolution jobs if queue is provided
     */
    async insertMarkets(
      markets: GeneratedMarket[]
    ): Promise<(typeof DB_SCHEMA.market.$inferSelect)[]> {
      const now = new Date();
      const insertedMarkets: (typeof DB_SCHEMA.market.$inferSelect)[] = [];

      for (const market of markets) {
        const votingEndsAt = new Date(
          now.getTime() + market.votingDays * MS_PER_DAY
        );
        const resolutionDeadline = new Date(
          votingEndsAt.getTime() + RESOLUTION_BUFFER_HOURS * 60 * 60 * 1000
        );

        const inserted = await db
          .insert(DB_SCHEMA.market)
          .values({
            title: market.title,
            description: market.description,
            category: market.category,
            resolutionCriteria: market.resolutionCriteria,
            betAmount: market.betAmount,
            votingEndsAt,
            resolutionDeadline,
            status: "ACTIVE",
            autoGenerated: true,
          })
          .returning();

        const record = inserted[0];
        if (record) {
          insertedMarkets.push(record);

          logger.info(
            {
              marketId: record.id,
              title: record.title,
              votingEndsAt,
            },
            "Market inserted"
          );
        }
      }

      return insertedMarkets;
    },

    /**
     * Full generation flow: generate + insert + schedule resolution
     */
    async generateAndInsertMarkets(input: GenerateMarketsInput): Promise<{
      generated: GenerateMarketsResult;
      inserted: (typeof DB_SCHEMA.market.$inferSelect)[];
    }> {
      const generated = await this.generateMarkets(input);
      const inserted = await this.insertMarkets(generated.markets);

      logger.info(
        {
          requested: input.count,
          generated: generated.markets.length,
          inserted: inserted.length,
        },
        "Market generation complete"
      );

      return { generated, inserted };
    },
  };
}

export type MarketGenerationService = ReturnType<
  typeof createMarketGenerationService
>;
