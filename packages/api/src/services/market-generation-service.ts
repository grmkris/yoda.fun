import { type AiClient, Output } from "@yoda.fun/ai";
import { FEATURES } from "@yoda.fun/ai/ai-config";
import { generateMarketImages } from "@yoda.fun/ai/image-generation";
import type { Database } from "@yoda.fun/db";
import { DB_SCHEMA } from "@yoda.fun/db";
import { desc } from "@yoda.fun/db/drizzle";
import type { Logger } from "@yoda.fun/logger";
import type { StorageClient } from "@yoda.fun/storage";
import {
  type GeneratedMarket,
  GeneratedMarketsResponseSchema,
  type GenerateMarketsInput,
  type GenerateMarketsResult,
} from "./market-generation-schemas";

interface MarketGenerationServiceDeps {
  db: Database;
  logger: Logger;
  aiClient: AiClient;
  storage?: StorageClient;
}

const MS_PER_DAY = 24 * 60 * 60 * 1000;
const RESOLUTION_BUFFER_HOURS = 6;

export function createMarketGenerationService({
  deps,
}: {
  deps: MarketGenerationServiceDeps;
}) {
  const { db, logger, aiClient, storage } = deps;

  return {
    /**
     * Generate new markets using AI
     * Returns validated market data ready for DB insertion
     */
    async generateMarkets(
      input: GenerateMarketsInput
    ): Promise<GenerateMarketsResult> {
      const startTime = Date.now();
      const config = FEATURES.marketGeneration;

      logger.info(
        { count: input.count, categories: input.categories },
        "Generating markets with AI"
      );

      // Get existing market titles to avoid duplicates
      const existingMarkets = await db
        .select({ title: DB_SCHEMA.market.title })
        .from(DB_SCHEMA.market)
        .orderBy(desc(DB_SCHEMA.market.createdAt))
        .limit(50);

      const existingTitles = existingMarkets.map((m) => m.title);

      // Build prompt context
      const promptContext = {
        currentDate: new Date().toISOString().split("T")[0] ?? "",
        categories: input.categories,
        existingMarketTitles: existingTitles,
        targetCount: input.count,
      };

      const systemPrompt = config.systemPrompt(promptContext);
      const model = aiClient.getModel(config.model);

      const response = await aiClient.generateText({
        model,
        output: Output.object({ schema: GeneratedMarketsResponseSchema }),
        system: systemPrompt,
        prompt: `Generate ${input.count} unique betting markets based on current events and trends. Focus on engaging, fun topics that will attract bettors.`,
      });

      const durationMs = Date.now() - startTime;

      logger.info(
        {
          marketsGenerated: response.output.markets.length,
          durationMs,
          tokensUsed: response.usage?.totalTokens,
        },
        "Markets generated successfully"
      );

      return {
        markets: response.output.markets,
        modelVersion: config.model.modelId,
        tokensUsed: response.usage?.totalTokens,
        durationMs,
      };
    },

    /**
     * Insert generated markets into the database
     * Also generates images if storage is configured
     */
    async insertMarkets(
      markets: GeneratedMarket[]
    ): Promise<(typeof DB_SCHEMA.market.$inferSelect)[]> {
      const now = new Date();
      const insertedMarkets: (typeof DB_SCHEMA.market.$inferSelect)[] = [];

      // Generate images for all markets if storage is configured
      let imageUrls = new Map<string, string | null>();
      if (storage) {
        const googleApiKey = aiClient.getProviderConfig().googleGeminiApiKey;
        if (googleApiKey) {
          logger.info({ count: markets.length }, "Generating market images");
          try {
            imageUrls = await generateMarketImages(markets, {
              googleApiKey,
              storage,
            });
            logger.info(
              { generated: [...imageUrls.values()].filter(Boolean).length },
              "Market images generated"
            );
          } catch (error) {
            logger.error({ error }, "Failed to generate market images");
          }
        }
      }

      for (const market of markets) {
        const votingEndsAt = new Date(
          now.getTime() + market.votingDays * MS_PER_DAY
        );
        const resolutionDeadline = new Date(
          votingEndsAt.getTime() + RESOLUTION_BUFFER_HOURS * 60 * 60 * 1000
        );

        const imageUrl = imageUrls.get(market.title) ?? null;

        const inserted = await db
          .insert(DB_SCHEMA.market)
          .values({
            title: market.title,
            description: market.description,
            category: market.category,
            resolutionCriteria: market.resolutionCriteria,
            betAmount: market.betAmount,
            imageUrl,
            votingEndsAt,
            resolutionDeadline,
            status: "ACTIVE",
            autoGenerated: true,
          })
          .returning();

        const record = inserted[0];
        if (record) {
          insertedMarkets.push(record);

          logger.info(
            {
              marketId: record.id,
              title: record.title,
              hasImage: !!imageUrl,
              votingEndsAt,
            },
            "Market inserted"
          );
        }
      }

      return insertedMarkets;
    },

    /**
     * Full generation flow: generate + insert + schedule resolution
     */
    async generateAndInsertMarkets(input: GenerateMarketsInput): Promise<{
      generated: GenerateMarketsResult;
      inserted: (typeof DB_SCHEMA.market.$inferSelect)[];
    }> {
      const generated = await this.generateMarkets(input);
      const inserted = await this.insertMarkets(generated.markets);

      logger.info(
        {
          requested: input.count,
          generated: generated.markets.length,
          inserted: inserted.length,
        },
        "Market generation complete"
      );

      return { generated, inserted };
    },
  };
}

export type MarketGenerationService = ReturnType<
  typeof createMarketGenerationService
>;
